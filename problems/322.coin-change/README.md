# Coin Change

> 题目地址: [https://leetcode-cn.com/problems/coin-change/](https://leetcode-cn.com/problems/coin-change/)

## 题目描述

给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

```
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

示例 2:

```
输入: coins = [2], amount = 3
输出: -1
```

**说明:**

你可以认为每种硬币的数量是无限的。

------

## 题解

### 方法一：动态规划

首先需要找到动态规划的转移方程，**我们令 f(n) 表示组成 n 美元的最少硬币数量**。

以 `coins = [1, 2, 5], amount = 11` 为例，`f(11)` 则表示组成 11 美元需要的最少硬币数，假设我们使用 1 个 5 美元的硬币，那么还需要判断组成 `11 - 5 = 6` 美元需要的最少硬币，也就是说 `f(11) = f(11 - 5) + 1 = f(6) + 1`，当然这里有 3 种类型的硬币，有可能使用 1 美元的硬币才是最少的，也有可能使用 2 美元的硬币才是最少的，所以我们需要从这 3 种硬币中找到一个最小的，如下：

```
f(n) = Math.min(
  f(n - 1) + 1,
  f(n - 2) + 1,
  f(n - 5) + 1
)
# 转移方程

       |-----|-----|-----|-----|-----|-----|-----|-----|-----|
f(5) = |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  | ... |
       |-----|-----|-----|-----|-----|-----|-----|-----|-----|
          ↑                 ↑     ↑-----|
          |                 |-----------|
          |-----------------------------|
# 图例
```

转移方程确定之后，只需要注意边界情况即可。

#### 代码实现

```js
function coinChange(coins, amount) {
  const f = [0];

  for (let n = 1; n <= amount; n++) {
    f[n] = Number.MAX_VALUE;
    for (let i = 0; i < coins.length; i++) {
      if (n - coins[i] >= 0) {
        f[n] = Math.min(f[n], f[n - coins[i]] + 1);
      }
    }
  }

  return f[amount] === Number.MAX_VALUE ? -1 : f[amount];
}
```

#### 复杂度分析

* 时间复杂度：$ O(nm) $. $n$ 为总金额 `amount`，$m$ 为硬币数量
* 空间复杂度：$ O(nm) $.
