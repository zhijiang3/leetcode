# Find Winner on a Tic Tac Toe Game

> 题目地址: [https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/](https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/)

## 题目描述

A 和 B 在一个 3 x 3 的网格上玩井字棋。

井字棋游戏的规则如下：

* 玩家轮流将棋子放在空方格 (" ") 上。
* 第一个玩家 A 总是用 "X" 作为棋子，而第二个玩家 B 总是用 "O" 作为棋子。
* "X" 和 "O" 只能放在空方格中，而不能放在已经被占用的方格上。
* 只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。
* 如果所有方块都放满棋子（不为空），游戏也会结束。
* 游戏结束后，棋子无法再进行任何移动。

给你一个数组 `moves`，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。

如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 `"Draw"`；如果仍会有行动（游戏未结束），则返回 `"Pending"`。

你可以假设 `moves` 都**有效**（遵循井字棋规则），网格最初是空的，A 将先行动。

示例 1：

```
输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
输出："A"
解释："A" 获胜，他总是先走。
"X  "    "X  "    "X  "    "X  "    "X  "
"   " -> "   " -> " X " -> " X " -> " X "
"   "    "O  "    "O  "    "OO "    "OOX"
```

示例 2：

```
输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
输出："B"
解释："B" 获胜。
"X  "    "X  "    "XX "    "XXO"    "XXO"    "XXO"
"   " -> " O " -> " O " -> " O " -> "XO " -> "XO "
"   "    "   "    "   "    "   "    "   "    "O  "
```

示例 3：

```
输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
输出："Draw"
输出：由于没有办法再行动，游戏以平局结束。
"XXO"
"OOX"
"XOX"
```

示例 4：

```
输入：moves = [[0,0],[1,1]]
输出："Pending"
解释：游戏还没有结束。
"X  "
" O "
"   "
```

提示：

* `1 <= moves.length <= 9`
* `moves[i].length == 2`
* `0 <= moves[i][j] <= 2`
* `moves` 里没有重复的元素。
* `moves` 遵循井字棋的规则。

------

## 题解

> 此算法参考：[https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/solution/java-wei-yun-suan-xiang-jie-shi-yong-wei-yun-suan-/](https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/solution/java-wei-yun-suan-xiang-jie-shi-yong-wei-yun-suan-/)

首先建立井字棋的坐标与数字二进制位的关系，如下：

```
  9      8      7      6      5      4      3      2      1     # 二进制位数
(2,2)  (2,1)  (2,0)  (1,2)  (1,1)  (1,0)  (0,2)  (0,1)  (0,0)   # 落子坐标

(0,0) = 000 000 001 = 1
(0,1) = 000 000 010 = 2
(0,2) = 000 000 100 = 4
(1,0) = 000 001 000 = 8
(1,1) = 000 010 000 = 16
(1,2) = 000 100 000 = 32
(2,0) = 001 000 000 = 64
(2,1) = 010 000 000 = 128
(2,2) = 100 000 000 = 256
```

那么接下来要做的就是，把玩家A、B落子的坐标转换成对应的二进制位即可。

假设 **玩家 A** 没有落子，其二进制位为：

$$
000\ 000\ 000
$$

当 **玩家 A** 落子在 `(0,2)` 时，那么我们只需要把二进制位的第 3 位改成 1 即可，即：

$$
000\ 000\ 100
$$

那么坐标与二进制位就需要一个转换，如下：

```
(0,0) => 1 # 1 左移 0 位，即需要 (0,0) = 0
(0,1) => 10 = 1 左移 1 位，即需要 (0,1) = 1
(0,2) => 100 = 1 左移 2 位，即需要 (0,2) = 2
(1,0) => 1000 = 1 左移 3 位，即需要 (1,0) = 3
(1,1) => 10000 = 1 左移 4 位，即需要 (1,1) = 4
(1,2) => 100000 = 1 左移 5 位，即需要 (1,2) = 5
(2,0) => 1000000 = 1 左移 6 位，即需要 (2,0) = 6
(2,1) => 10000000 = 1 左移 7 位，即需要 (2,1) = 7
(2,2) => 100000000 = 1 左移 8 位，即需要 (2,2) = 8
```

显然，坐标转换后的值形成一个等差数列，那么有式子：

$$
a_{n} = ax + by = n - 1
$$

我们计算 $ a_{5} $ 和 $ a_{6} $ 得到式子：

$$
\begin{cases}
a + b = 4 & a_{5} \\\\
a + 2b = 5 & a_{6}
\end{cases}
$$

解出以上式子得到 $ a = 3，b = 1 $，即：

$$
a_{n} = 3x + y = n -1
$$

把坐标带入以上式子，再把 **1 左移式子的结果**即可得到**坐标对应的二进制位**。

接下来处理井字棋游戏的结束条件，结束条件可以分为如下 8 种（3横 3竖 2交叉）：

```
(0,0) (0,1) (0,2) # 第一行
对应二进制位：000 000 111
对应的十进制：7

(1,0) (1,1) (1,2) # 第二行
对应二进制位：000 111 000
对应的十进制：56

(2,0) (2,1) (2,2) # 第三行
对应二进制位：111 000 111
对应的十进制：448

(0,0) (1,0) (2,0) # 第一列
对应二进制位：001 001 001
对应的十进制：73

(0,1) (1,1) (2,1) # 第二列
对应二进制位：010 010 010
对应的十进制：146

(0,2) (1,2) (2,2) # 第三列
对应二进制位：100 100 100
对应的十进制：292

(0,0) (1,1) (2,2) # 左上到右下
对应二进制位：100 010 001
对应的十进制：273

(0, 2) (1, 1) (2, 0) # 右上到左下
对应二进制位：001 010 100
对应的十进制：84
```

只需要拿 **A、B 落子记录的二进制位与答案的二进制位比较（按位与）** 即可知道游戏的结果。

### 代码实现

```js
function tictactoe(moves) {
  let a = 0;
  let b = 0;

  for (let i = 0; i < moves.length; i++) {
    const binaryBit = 3 * moves[i][0] + moves[i][1];

    // a ^ b 按位异或操作，对比的两个位必须要一个 0 一个 1，结果才为 1
    if ((i & 1) === 1) { // odd
      b ^= 1 << binaryBit;
    } else { // even
      a ^= 1 << binaryBit;
    }
  }

  const answers = [7, 56, 448, 73, 146, 292, 273, 84];
  for (let answer of answers) {
    // a & b 按位与操作，对比的两个位必须都是 1，结果才为 1
    if ((a & answer) === answer) {
      return "A";
    } else if ((b & answer) === answer) {
      return "B";
    }
  }

  return moves.length >= 9 ? "Draw" : "Pending";
}
```

### 复杂度分析

* 时间复杂度：$ O(mn) $. $ m $ 为 `answers` 的长度，$ n $ 为 `moves` 的长度（实际上 $ n = 8，m = 9 $）
* 空间复杂度：$ O(m) $. 我们使用了一个数组保存答案
