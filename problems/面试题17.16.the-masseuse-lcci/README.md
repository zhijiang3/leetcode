# The Masseuse LCCI

> 题目地址: [https://leetcode-cn.com/problems/the-masseuse-lcci/](https://leetcode-cn.com/problems/the-masseuse-lcci/)

## 题目描述

一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

**注意**：本题相对原题稍作改动

示例 1：

```
输入： [1,2,3,1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
```

示例 2：

```
输入： [2,7,9,3,1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。
```

示例 3：

```
输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。
```

------

## 题解

### 动态规划

令 `dp[n]` 为前 n 次预约的最长总时长，那么有转移方程：

```
dp[n] = Max(dp[n - 2], dp[n - 3]) + nums[n];
```

这里的 `dp[n - 2]` 和 `dp[n - 3]` 的意思是，取前 2 次预约或前 3 次预约的最长时长。

因为预约服务之间需要休息，所以取前 2 次预约或前 3 次预约的最长时长，这里不会取到前 4 次，因为如果取前 4 次，那么就会有预约浪费掉，达不到最长时长的效果。

#### 代码实现

```js
function massage(nums) {
  const dp = [];

  let ans = 0;
  for (let i = 0; i < nums.length; ++i) {
    dp[i] = Math.max(dp[i - 2] || 0, dp[i - 3] || 0) + nums[i];
    ans = Math.max(ans, dp[i]);
  }
  return ans;
}
```

#### 复杂度分析

* 时间复杂度：$ O(n) $.
* 空间复杂度：$ O(n) $.
