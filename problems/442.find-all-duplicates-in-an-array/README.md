# Find All Duplicates in an Array

> 题目地址: [https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)

## 题目描述
给定一个整数数组 `a`，其中 `1 ≤ a[i] ≤ n`（n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在 $O(n)$ 时间复杂度内解决这个问题吗？

示例：

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]
```

------

## 题解

通常的做法是，对出现的某个数进行标记，当被标记的数再次出现时，我们就知道这个数重复了，如 `[3, 2, 2]`：

```
依次遍历数组
3 => 标记数字 3
2 => 标记数字 2
2 => 数字 2 已经被标记过了，所以 2 重复了
```

我们可以使用**哈希表**的方式去标记这个数字，但是题目要求算法不使用额外空间。

所以我们可以借助题目的限定条件 `1 ≤ a[i] ≤ n`，去实现不使用额外空间的算法，具体算法以 `[3, 2, 2]` 为例子：

```
 ↓
[3, 2, 2]
遍历数组
--------------
 ↓
[3, 2, -2]
遇到数字 3，把 a[2] = -a[2]
--------------
    ↓
[3, 2, -2]
继续遍历数组
--------------
     ↓
[3, -2, -2]
遇到数字 2，把 a[1] = -a[1]
--------------
         ↓
[3, -2, -2]
继续遍历数组
--------------
         ↓
[3, -2, -2]
遇到数字 -2，这里取正数 2，a[1] < 0 说明之前遇到过 2，所以把 2 添加到重复数组中
-------------
最终结果 [2]
```

在这个算法中不需要考虑越界和负数的问题，因为条件限定了 `1 ≤ a[i] ≤ n`。

### 代码实现

```js
function findDuplicates(nums) {
  const res = [];

  for (let n of nums) {
    const i = Math.abs(n) - 1;

    if (nums[i] < 0) {
      res.push(Math.abs(n));
    } else {
      nums[i] = -nums[i];
    }
  }

  return res;
}
```

### 复杂度分析

* 时间复杂度：$ O(n) $.
* 空间复杂度：$ O(1) $.
