# Available Captures For Rook

> 题目地址: [https://leetcode-cn.com/problems/available-captures-for-rook/](https://leetcode-cn.com/problems/available-captures-for-rook/)

## 题目描述

在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。

车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。

返回车能够在一次移动中捕获到的卒的数量。

示例 1：

![example 1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_1_improved.PNG)

```
输入：[
  [".",".",".",".",".",".",".","."],
  [".",".",".","p",".",".",".","."],
  [".",".",".","R",".",".",".","p"],
  [".",".",".",".",".",".",".","."],
  [".",".",".",".",".",".",".","."],
  [".",".",".","p",".",".",".","."],
  [".",".",".",".",".",".",".","."],
  [".",".",".",".",".",".",".","."]
]
输出：3
解释：
在本例中，车能够捕获所有的卒。
```

示例 2：

![example 2](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_2_improved.PNG)

```
输入：[
  [".",".",".",".",".",".",".","."],
  [".","p","p","p","p","p",".","."],
  [".","p","p","B","p","p",".","."],
  [".","p","B","R","B","p",".","."],
  [".","p","p","B","p","p",".","."],
  [".","p","p","p","p","p",".","."],
  [".",".",".",".",".",".",".","."],
  [".",".",".",".",".",".",".","."]
]
输出：0
解释：
象阻止了车捕获任何卒。
```

示例 3：

![examole 3](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_3_improved.PNG)

```
输入：[
  [".",".",".",".",".",".",".","."],
  [".",".",".","p",".",".",".","."],
  [".",".",".","p",".",".",".","."],
  ["p","p",".","R",".","p","B","."],
  [".",".",".",".",".",".",".","."],
  [".",".",".","B",".",".",".","."],
  [".",".",".","p",".",".",".","."],
  [".",".",".",".",".",".",".","."]
]
输出：3
解释： 
车可以捕获位置 b5，d6 和 f5 的卒。
```

提示：

* `board.length == board[i].length == 8`
* `board[i][j]` 可以是 `'R'`，`'.'`，`'B'` 或 `'p'`
* 只有一个格子上存在 `board[i][j] == 'R'`

------

## 题解

### 代码实现

```js
function numRookCaptures(board) {
  let Rx, Ry; // 记录 R(白色车) 的位置
  for (let x = 0; x < 8; ++x) {
    for (let y = 0; y < 8; ++y) {
      if (board[x][y] === "R") {
        Rx = x;
        Ry = y;
        break;
      }
    }
  }

  // 东南西北方向向量
  const dx = [-1, 0, 1, 0];
  const dy = [0, -1, 0, 1]

  let ans = 0;
  let dRx, dRy;
  for (let i = 0; i < 4; ++i) {
    dRx = Rx;
    dRy = Ry;

    // 朝一个方向一直走，直到遇到停止的条件
    while (true) {
      dRx += dx[i];
      dRy += dy[i];

      if (!(dRx >= 0 && dRx < 8 && dRy >= 0 && dRy < 8)) break;
      if (board[dRx][dRy] === "B") break;
      if (board[dRx][dRy] === "p") {
        ans++;
        break;
      }
    }
  }

  return ans;
}
```

### 复杂度分析

* 时间复杂度：$ O(n^2) $.
* 空间复杂度：$ O(1) $.
