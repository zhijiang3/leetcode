# Sort Colors

> 题目地址: [https://leetcode-cn.com/problems/sort-colors/](https://leetcode-cn.com/problems/sort-colors/)

## 题目描述

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**注意:**

不能使用代码库中的排序函数来解决这道题。

**示例:**

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

**进阶：**

* 一个直观的解决方案是使用计数排序的两趟扫描算法。
  首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
* 你能想出一个仅使用常数空间的一趟扫描算法吗？

------

## 题解

为了在常数空间下完成算法，我们使用 3 个指针：

* `low` 记录数字 0 应该插入的位置，初始值为 0
* `high` 记录数字 2 应该插入的位置，初始值为 `nums.length - 1`
* `i` 遍历数组。

当 `nums[i] === 0` 时，我们把 `i` 和 `low` 索引下的值进行交换，并让 `low + 1` 移动到下一个插入的位置，接着我们对进行 `i + 1` 的操作，**这里不需要担心交换过来的值是没经过验证的，因为当 `i` 和 `low` 不同步时，说明在 `i` 之前有遇到过数字 1 且 `low` 停留在了数字 1 的位置，那么交换过来的数字肯定是 1**。

当 `nums[i] === 2` 时，同样的，我们把 `i` 和 `high` 索引下的值进行交换，并让 `high - 1` 移动到下一个插入的位置，**注意`i` 不需要移动，因为此时交换过来的的值是没有经过验证的，所以 `i` 需要停留在原地以验证交换过来的值**。

当 `nums[i] === 1` 时，继续遍历即可。

以 `[2, 0, 2, 1, 1, 0]` 为例：

```
low            high
 ↓              ↓
[2, 0, 2, 1, 1, 0]    # 当前值为 2
 ↑
 i

low         high
 ↓           ↓
[0, 0, 2, 1, 1, 2]    # 交换 i 和 high 的值，并让 high 自减
 ↑
 i
------------------------------------------
low         high
 ↓           ↓
[0, 0, 2, 1, 1, 2]    # 当前值为 0
 ↑
 i

   low      high
    ↓        ↓
[0, 0, 2, 1, 1, 2]    # 交换 i 和 low 的值，并让 low 和 i 自增
    ↑
    i
------------------------------------------
   low      high
    ↓        ↓
[0, 0, 2, 1, 1, 2]    # 当前值为 0
    ↑
    i

      low   high
       ↓     ↓
[0, 0, 2, 1, 1, 2]    # 交换 i 和 low 的值，并让 low 和 i 自增
       ↑
       i
------------------------------------------
      low   high
       ↓     ↓
[0, 0, 2, 1, 1, 2]    # 当前值为 2
       ↑
       i

     low  high
       ↓  ↓
[0, 0, 1, 1, 2, 2]    # 交换 i 和 high 的值，并让 high 自减
       ↑
       i
------------------------------------------
     low  high
       ↓  ↓
[0, 0, 1, 1, 2, 2]    # 当前值为 1
       ↑
       i

     low  high
       ↓  ↓
[0, 0, 1, 1, 2, 2]    # 继续遍历
          ↑
          i
------------------------------------------
     low  high
       ↓  ↓
[0, 0, 1, 1, 2, 2]    # 当前值为 1
          ↑
          i

     low  high
       ↓  ↓
[0, 0, 1, 1, 2, 2]    # 继续遍历
             ↑        # 算法到这里就可以结束了，high 之后的元素都是处理过的
             i
------------------------------------------
```

### 代码实现

```js
/**
 * swap the value of i and j for arr
 * @param {number[]} arr
 * @param {number} i
 * @param {number} j
 */
function swap(arr, i, j) {
  if (i === j) return;

  arr[i] ^= arr[j];
  arr[j] ^= arr[i];
  arr[i] ^= arr[j];
}

/**
 * @param {number[]} nums
 */
export default function sortColors(nums) {
  let low = 0;
  let high = nums.length - 1
  let i = 0;

  while (i <= high) {
    if (nums[i] === 2) {
      swap(nums, i, high--);
    } else if (nums[i] === 0) {
      swap(nums, i++, low++);
    } else {
      i++;
    }
  }
}
```

### 复杂度分析

* 时间复杂度：$ O(n) $.
* 空间复杂度：$ O(1) $.
