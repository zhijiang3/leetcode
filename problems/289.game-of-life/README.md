# Game of Life

> 题目地址: [https://leetcode-cn.com/problems/game-of-life/](https://leetcode-cn.com/problems/game-of-life/)

## 题目描述

根据 <a href="https://baike.baidu.com/item/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/2926434?fr=aladdin" target="_blank">百度百科</a>，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个包含 `m × n` 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；

根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。

示例：

```
输入： 
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]
输出：
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]
```

**进阶：**

* 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。
* 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？

------

## 题解

遍历面板，对原面板需要存活或死亡的细胞进行标记，在遍历完成后统一修改原面板的数据。

### 代码实现

```js
// 方向数组
const dx = [-1, 0, 1, 1, 1, 0, -1, -1];
const dy = [-1, -1, -1, 0, 1, 1, 1, 0];

/**
 * @param {number[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
function gameOfLife(board) {
  const m = board.length, n = board[0].length;

  let live, x1, y1;
  for (let x = 0; x < m; ++x) {
    for (let y = 0; y < n; ++y) {

      // 获取周围活细胞数量
      live = 0;
      for (let i = 0; i < dx.length; ++i) {
        x1 = x + dx[i];
        y1 = y + dy[i];
        if (x1 >= 0 && x1 < m && y1 >= 0 && y1 < n) {
          if (Math.abs(board[x1][y1]) === 1)
            live++;
        }
      }

      if (board[x][y] === 1) {
        // 周围活细胞过多，当前细胞死亡
        if (live <= 1 || live >= 4) board[x][y] = -1;
      } else {
        // 周围只有 3 个活细胞，当前细胞复活
        if (live === 3) board[x][y] = 2;
      }

    }
  }

  for (let x = 0; x < m; ++x) {
    for (let y = 0; y < n; ++y) {
      board[x][y] = board[x][y] > 0 ? 1 : 0;
    }
  }
}
```

### 复杂度分析

* 时间复杂度：$ O(mn) $.
* 空间复杂度：$ O(1) $.
