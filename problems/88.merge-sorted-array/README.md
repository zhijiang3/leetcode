# Merge Sorted Array

> 题目地址: [https://leetcode-cn.com/problems/merge-sorted-array/](https://leetcode-cn.com/problems/merge-sorted-array/)

## 题目描述
给定两个有序整数数组 *nums1* 和 *nums2*，将 *nums2* 合并到 *nums1* 中，使得 *nums1* 成为一个有序数组。

说明:

* 初始化 *nums1* 和 *nums2* 的元素数量分别为 *m* 和 *n*。
* 你可以假设 *nums1* 有足够的空间（空间大小大于或等于 *m + n*）来保存 *nums2* 中的元素。

示例:

```
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

------

## 题解

### 双指针 + 从后往前

对于给定的两个升序的数组，我们从后往前比较比较 `nums1[m]` 和 `nums2[n]`，比较出来的数，一定是最大的，而且是在数组索引 `m + n` 位置的值，假设在第一次比较中取了 `nums1` 的值，那么我们把 `m - 1` 移动到 `nums1` 第二大的数 (注意：`nums2` 的 `n` 不需要自减)；反之对于 `nums2` 也是一样的，直到 `m + n` 走完为止。

以 `nums1 = [1,2,3,0,0,0], nums2 = [2,5,6], m = 3, n = 3` 为例：

```
               m
               ↓                 # 比较 nums1[m] 和 nums2[n] 的值
nums1 = [1, 2, 3, 0, 0, 6]       # 这里 nums2[n] 的值比较大，所以 m + n 位置的值设置为 nums2[n]
nums2 = [2, 5, 6]       ↑
               ↑      m + n
               n

               m
               ↓
nums1 = [1, 2, 3, 0, 0, 6]       # 把 nums2 移动到第二大的数，继续比较
nums2 = [2, 5, 6]    ↑
            ↑      m + n         # 注意，这里因为 n - 1 所以，m + n 的位置也随之发生变化
            n
------------------------------------------
               m
               ↓                 # 比较 nums1[m] 和 nums2[n] 的值
nums1 = [1, 2, 3, 0, 5, 6]       # 这里 nums2[n] 的值比较大，所以 m + n 位置的值设置为 nums2[n]
nums2 = [2, 5, 6]    ↑
            ↑      m + n
            n

               m
               ↓
nums1 = [1, 2, 3, 0, 5, 6]       # 把 nums2 移动到第三大的数，继续比较
nums2 = [2, 5, 6] ↑
         ↑      m + n
         n
------------------------------------------
               m
               ↓                 # 比较 nums1[m] 和 nums2[n] 的值
nums1 = [1, 2, 3, 3, 5, 6]       # 这里 nums1[m] 的值比较大，所以 m + n 位置的值设置为 nums1[m]
nums2 = [2, 5, 6] ↑
         ↑      m + n
         n

            m  m + n
            ↓  ↓
nums1 = [1, 2, 3, 3, 5, 6]       # 把 nums1 移动到第二大的数，继续比较
nums2 = [2, 5, 6]
         ↑
         n
------------------------------------------
# ... 以此类推，最终得到
nums1 = [1, 2, 2, 3, 5, 6]
```

#### 代码实现

```js
function merge(nums1, m, nums2, n) {
  while (n > 0) {
    if (nums1[m - 1] >= nums2[n - 1]) {
      nums1[m + n - 1] = nums1[--m];
    } else {
      nums1[m + n - 1] = nums2[--n];
    }
  }
}
```

#### 复杂度分析

* 时间复杂度：$ O(n) $. $n$ 是 `nums2` 的长度
* 空间复杂度：$ O(1) $.
